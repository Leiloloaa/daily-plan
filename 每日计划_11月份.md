# 11月计划

**主题**：不破不立

**目标**：

- typescript 重铸
  - 首周跟随 ts 小组打卡学习
- mini-vue 源码学习与 重敲
- 高效工作
- 坚持运动

## 第一周

**重要部分**：typescript 重铸

### 11.1

**今日计划**

- [x] 整理笔记
- [x] 工作安排
- [x] 健身计划

**学习笔记**

**今日总结**

> 逆水行舟不进则退啊！坚持了一段时间之后，同样也不能够松懈！

**明日早读**

- [x] 6.55 起床
- [x] 早读半个小时

### 11.2

- [x] ts one
  - [x] 输出文档
- [x] 工作安排
- [ ] 健身计划

**学习笔记**

> TS 学习笔记一：https://juejin.cn/post/7025787233131036686

ts one 总结

- ts 和 js 的区别
  - ts 是 js 的超集
  - js 是弱类型语言
  - ts 的类型注解有利严格的判断输入输出的变量
  - ts 的类型注解只存在于开发环境
- 类型注解
  ```ts
  // 静态类型注解
  let count:number = 1

  // 函数参数
  const setCount(num:number){
    ...
  }

  // 函数返回值
  const getCount() : number{
    return count;
  }

  // 联合类型
  let name:string|number
  ```
- type 类型别名和 interface 接口的区别
  - 扩展方式不同
    - type 只能通过 & 字符
    - interface 可以通过 extends 扩展
  - 接口重名会自动合并，而 type 则会报错
  - interface 只能是一个对象，可以接收任何类型type 可以直接定义基础类型

**今日总结**

> 你若盛开，清风自来。倘若想要获得更多的财富，就要让自己变得更有价值。

**明日早读**

- [x] 6.55 起床
- [ ] 早起学习半个小时

### 11.3

- [x] ts two
  - [x] 输出文档
- [x] es6 class
- [x] 玩转 Vue3 全家桶
- [x] 工作安排
- [x] 健身计划

**学习笔记**

> TS 学习笔记二：https://juejin.cn/post/7026166743869423652

ts two

- 类型保护
  - 类型断言 as、类型收窄 in typeof instanceof
  ```ts
  // as 类型断言就是通过断言的方式确定传递过来的准确值
  interface People  {
    name:string,
    age:number,
    printPeopleOut:()=>{console.log('People')}
  }
  let Chinese = {name:'zs',age:18} as People

  // 类型收榨 in
  interface Angel  {
    name:string,
    age:number,
    printAngelOut:()=>{console.log('Angel')}
  }
  function Print(yourType:People|Angel){
    if('printAngelOut' in yourType){
      yourType.printAngelOut()
    }else{
      yourType.printPeopleOut()
    }
  }

  // 类型保护之 typeof
  function add(first: string | number, second: string | number) {
    if (typeof first === "string" || typeof second === "string") {
      return `${first}${second}`;
    }
    return first + second;
  }

  // 类型保护之 instanceof 只能用在类上
  class NumberObj {
    count: number;
  }
  function addObj(first: object | NumberObj, second: object | NumberObj) {
    if (first instanceof NumberObj && second instanceof NumberObj) {
      return first.count + second.count;
    }
    return 0;
  }
  ```
  - 常用类型
    - 文字类型
    - 枚举类型
    - never类型
      - void 表示没有任何类型，never 表示永远不存在的值的类型
  ```ts
  // 文字类型
  function changeXY(x:"top"|"center"|'bottom',y:"top"|"center"|'bottom'){
    ...
  }
  // 枚举类型
  enum Status{
    SUCCESS,
    FAIL,
    WARN
  }
  function getStatus(status:number){
    Status[status] && console.log(Status[status])
  }
  getStatus(0) // SUCCESS
  ```

**今日总结**

> 要坚持运动，健康的体质是我们做其它一切事物的基石。养生从现在开始了~~~

**明日早读**

- [x] 6.55 起床
- [x] 早起学习半个小时

### 11.4

**今日计划**

- [x] ts three
  - [x] 输出文档
- [x] mini-vue：provide、inject
- [ ] 阅读 重构 半小时
- [ ] 解决 博客 和 图床 的问题
- [ ] 总结 ES6 的 class
- [x] 工作安排
- [x] 健身计划

**学习笔记**

ts three

> https://juejin.cn/post/7026609729560379400

**今日总结**

> 今天因为一些事情，一些任务没有完成，以至于需要延期执行！切记，以后尽力要完成！

**明日早读**

- [ ] 6.55 起床
- [ ] 初看重构

**延期计划**

- [ ] 解决 博客 和 图床 的问题
  - 没有完全找到方案修复，明天需要还原
- [ ] 总结 ES6 的 class
  - JS 系统脑图

### 11.5

**今日计划**

- [ ] 完成延期计划
  - [ ] 解决 博客 和 图床 的问题
    - 没有完全找到方案修复，明天需要还原
  - [x] 总结 ES6 的 class
    - JS 系统脑图
- [x] 重敲 mini-vue：provide 和 inject
- [x] ts four
- [x] 工作安排
- [x] 健身计划

**学习笔记**

es6 class

- 可以认为是构造函数的语法糖
- 和构造函数一样必须使用 new 关键字
- class 中的属性是绑定在实例身上，而方法是在原型上
- 使用 extends 继承类，但是子类需要使用 super 来继承父类中的属性和方法
- super 可以当成函数或者是对象来使用
  - 作为函数时，`super()`只能用在子类的构造函数之中，用在其他地方就会报错。
  - `super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
- 加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用

**今日总结**

> 今天花了一大半的时间处理这个 Nginx 的问题，总感觉在外层打转，做些无用功。还是找个视频看下，如何处理吧！也别把希望寄托于别人身上！人生中很多事情要靠自己，别人的举手之劳才会帮。切记切记，自己可以搞定，之前都可以，现在为什么不行！肯定可以，只是时间的问题！

**明日计划**

- [ ] 6.55 起
- [ ] 明天要把 JS 系统脑图复习一下

### 11.6

**今日计划**

- [x] 玩转 Vue3 全家桶
- [x] 解决博客、图床的问题
- [x] 周总结
- [x] 工作安排
- [x] 健身计划

**学习笔记**

- 玩转 Vue3 全家桶 --- 动画
  - 提供 transition 可以控制一个元素的动画
  - 提供 transition-group 实现列表的动画
  - 要清楚动画过程中的几个角色，如下
  ```css
  /* 通过 fade-enter-active 和 fade-leave-active 两个 class，去控制动画全程的过渡属性。设置 opacity 有 0.5 秒的过渡时间，并且在元素进入前和离开后设置 opacity 为 0。 */
  .fade-enter-active,
  .fade-leave-active {
    transition: opacity 0.5s linear;
  }

  .fade-enter-from,
  .fade-leave-to {
    opacity: 0;
  }
  ```


**今日总结**

> 咱们不要因为别人的一些话就受打击了，你有那么脆弱吗？别人说几句话就让你寝食难安？内心足够坚强的人是不会受几句话的影响，因为他清楚的知道自己想要的东西，想要去的地方！

**明日早读**

> 明天周日，睡个懒觉

### 11.7

**今日计划**

- [x] 暂无计划

**学习笔记**

**今日总结**

> 按照月初的计划，上周是对 ts 的进行了总结。下周要重敲 mini-vue 源码，并在掘金上输出文档！加油把！自信是自己给的，从来不是别人施舍！

**明日早读**

- [x] JS 系统脑图
- [x] 第四关脑图

## 第二周

### 11.8

**今日计划**

- [x] 重要任务
  - [x] 玩转 vue3 全家桶
  - [x] 重敲 mini-vue 第一天
    - [x] 输出文档
  - [x] 工作任务
  - [x] 健身计划
- [x] 可选任务
  - [x] 防抖和节流的实现

**学习笔记**

- 玩转 vue3 全家桶
  - 实现 mini-vuex（笔记明天补上）
- 重敲 mini-vue 前置准备（掘金输出）
  - Vue3 新特性
  - TDD 测试驱动开发
- 节流和防抖
  - 节流：频繁的触发一个事件，但是每隔一段时间只触发一次
  - 防抖：频繁的触发一个事件，但是只触发最后一次

**今日总结**

> 有计划，有目标的去实现计划中的事情，这个过程，也是成长。今天看到一句话，说是，每一个成功的都有一段静默的时间。这段静默的时间内，不断的拔高自己，朝着目标前进！目光所至，定能勇往无前！

**明日早读**

- [ ] mini-vue 源码视频

### 11.9

**今日计划**

- [x] 总结 mini-vuex、手写节流和防抖
- [x] 发布 mini-vue<一>
- [x] mini-vue 源码视频
- [x] 工作安排
- [ ] 健身计划

**学习笔记**

节流和防抖

- 节流：根据字面意思，开源节流，请求很多，但是每隔一段时间只触发一次
  - 上拉刷新、高频按钮提交
  - 举个例子：地铁乘车，刷卡过闸机，时间都是固定的
- 防抖：抖动，进进出出，但是只触发最后一次
  - 输入框搜索
  - 举个例子：坐公交车，上车时，每上一个人都会多等几秒（取最后一次）

节流：控制只能一段事件触发一次，有 timer 就退出（地铁闸机）
防抖：控制去最后一次，有 timer 就清空，重新计时（公交上车）

实现

```js
// 节流函数 每段时间触发一次
function throttle(fn,delay){
  var timer = null
  return function(){
    if(timer) return
    timer = setTimeout(()=>{
      // 如果有 this 指向问题
      // 需要使用 fn.apply(this,arguments)
      fn()
      timer = null
    },delay)
  }
}
```
```js
// 防抖函数 每段时间内触发 只取最后一次
function debounce(fn,delay){
  var timer = null
  return function(){
    if(timer){
      clearTimeout(timer)
    }
    timer = setTimeout(()=>{
      fn()
      timer = null
    },delay)
  }
}
```

mini-vuex

```js
import { inject, reactive } from 'vue';

const STORE_KEY = '__store__';

// 还未实现 action 和 getter
class Store {
    constructor(options) {
            this.$options = options;
            // let temp = options.state();
            this._state = reactive({
                data: options.state
            });
            this._mutations = options.mutations;
        }
        // main.js入口处app.use(store)的时候，会执行这个函数
    install(app) {
        app.provide(STORE_KEY, this);
    }
    get state() {
        return this._state.data;
    }
    commit = (type, payload) => {
        const entry = this._mutations[type];
        entry && entry(this.state, payload);
    };
}

export function createStore(options) {
    return new Store(options);
}

export function useStore() {
    return inject(STORE_KEY);
}
```


**今日总结**

> 时刻要记住：路漫漫其修远兮，吾将上下而求索。成功都没有那么容易，一定要将自己压低，沉下来思考问题。

**明日早读**

- [ ] 复习 mini-vuex

### 11.10

**今日计划**

- [ ] 闭包的用处、promise 的使用
- [ ] 第二篇 mini-vue 文章
  - [ ] 需要阅读源码
- [ ] 工作计划
  - [ ] v-ben 的项目

**学习笔记**

**今日总结**

> 

**明日早读**

- [ ] 