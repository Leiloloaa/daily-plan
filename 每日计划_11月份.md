# 11月计划

**主题**：不破不立

**目标**：

- typescript 重铸
  - 首周跟随 ts 小组打卡学习
- mini-vue 源码学习与 重敲
- 高效工作
- 坚持运动

## 第一周

**重要部分**：typescript 重铸

### 11.1

**今日计划**

- [x] 整理笔记
- [x] 工作安排
- [x] 健身计划

**学习笔记**

**今日总结**

> 逆水行舟不进则退啊！坚持了一段时间之后，同样也不能够松懈！

**明日早读**

- [x] 6.55 起床
- [x] 早读半个小时

### 11.2

- [x] ts one
  - [x] 输出文档
- [x] 工作安排
- [ ] 健身计划

**学习笔记**

> TS 学习笔记一：https://juejin.cn/post/7025787233131036686

ts one 总结

- ts 和 js 的区别
  - ts 是 js 的超集
  - js 是弱类型语言
  - ts 的类型注解有利严格的判断输入输出的变量
  - ts 的类型注解只存在于开发环境
- 类型注解
  ```ts
  // 静态类型注解
  let count:number = 1

  // 函数参数
  const setCount(num:number){
    ...
  }

  // 函数返回值
  const getCount() : number{
    return count;
  }

  // 联合类型
  let name:string|number
  ```
- type 类型别名和 interface 接口的区别
  - 扩展方式不同
    - type 只能通过 & 字符
    - interface 可以通过 extends 扩展
  - 接口重名会自动合并，而 type 则会报错
  - interface 只能是一个对象，可以接收任何类型type 可以直接定义基础类型

**今日总结**

> 你若盛开，清风自来。倘若想要获得更多的财富，就要让自己变得更有价值。

**明日早读**

- [x] 6.55 起床
- [ ] 早起学习半个小时

### 11.3

- [x] ts two
  - [x] 输出文档
- [x] es6 class
- [x] 玩转 Vue3 全家桶
- [x] 工作安排
- [x] 健身计划

**学习笔记**

> TS 学习笔记二：https://juejin.cn/post/7026166743869423652

ts two

- 类型保护
  - 类型断言 as、类型收窄 in typeof instanceof
  ```ts
  // as 类型断言就是通过断言的方式确定传递过来的准确值
  interface People  {
    name:string,
    age:number,
    printPeopleOut:()=>{console.log('People')}
  }
  let Chinese = {name:'zs',age:18} as People

  // 类型收榨 in
  interface Angel  {
    name:string,
    age:number,
    printAngelOut:()=>{console.log('Angel')}
  }
  function Print(yourType:People|Angel){
    if('printAngelOut' in yourType){
      yourType.printAngelOut()
    }else{
      yourType.printPeopleOut()
    }
  }

  // 类型保护之 typeof
  function add(first: string | number, second: string | number) {
    if (typeof first === "string" || typeof second === "string") {
      return `${first}${second}`;
    }
    return first + second;
  }

  // 类型保护之 instanceof 只能用在类上
  class NumberObj {
    count: number;
  }
  function addObj(first: object | NumberObj, second: object | NumberObj) {
    if (first instanceof NumberObj && second instanceof NumberObj) {
      return first.count + second.count;
    }
    return 0;
  }
  ```
  - 常用类型
    - 文字类型
    - 枚举类型
    - never类型
      - void 表示没有任何类型，never 表示永远不存在的值的类型
  ```ts
  // 文字类型
  function changeXY(x:"top"|"center"|'bottom',y:"top"|"center"|'bottom'){
    ...
  }
  // 枚举类型
  enum Status{
    SUCCESS,
    FAIL,
    WARN
  }
  function getStatus(status:number){
    Status[status] && console.log(Status[status])
  }
  getStatus(0) // SUCCESS
  ```

**今日总结**

> 要坚持运动，健康的体质是我们做其它一切事物的基石。养生从现在开始了~~~

**明日早读**

- [x] 6.55 起床
- [x] 早起学习半个小时

### 11.4

**今日计划**

- [x] ts three
  - [x] 输出文档
- [x] mini-vue：provide、inject
- [ ] 阅读 重构 半小时
- [ ] 解决 博客 和 图床 的问题
- [ ] 总结 ES6 的 class
- [x] 工作安排
- [x] 健身计划

**学习笔记**

ts three

> https://juejin.cn/post/7026609729560379400

**今日总结**

> 今天因为一些事情，一些任务没有完成，以至于需要延期执行！切记，以后尽力要完成！

**明日早读**

- [ ] 6.55 起床
- [ ] 初看重构

**延期计划**

- [ ] 解决 博客 和 图床 的问题
  - 没有完全找到方案修复，明天需要还原
- [ ] 总结 ES6 的 class
  - JS 系统脑图

### 11.5

**今日计划**

- [ ] 完成延期计划
  - [ ] 解决 博客 和 图床 的问题
    - 没有完全找到方案修复，明天需要还原
  - [x] 总结 ES6 的 class
    - JS 系统脑图
- [x] 重敲 mini-vue：provide 和 inject
- [x] ts four
- [x] 工作安排
- [x] 健身计划

**学习笔记**

es6 class

- 可以认为是构造函数的语法糖
- 和构造函数一样必须使用 new 关键字
- class 中的属性是绑定在实例身上，而方法是在原型上
- 使用 extends 继承类，但是子类需要使用 super 来继承父类中的属性和方法
- super 可以当成函数或者是对象来使用
  - 作为函数时，`super()`只能用在子类的构造函数之中，用在其他地方就会报错。
  - `super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
- 加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用

**今日总结**

> 今天花了一大半的时间处理这个 Nginx 的问题，总感觉在外层打转，做些无用功。还是找个视频看下，如何处理吧！也别把希望寄托于别人身上！人生中很多事情要靠自己，别人的举手之劳才会帮。切记切记，自己可以搞定，之前都可以，现在为什么不行！肯定可以，只是时间的问题！

**明日计划**

- [ ] 6.55 起
- [ ] 明天要把 JS 系统脑图复习一下

### 11.6

**今日计划**

- [x] 玩转 Vue3 全家桶
- [x] 解决博客、图床的问题
- [x] 周总结
- [x] 工作安排
- [x] 健身计划

**学习笔记**

- 玩转 Vue3 全家桶 --- 动画
  - 提供 transition 可以控制一个元素的动画
  - 提供 transition-group 实现列表的动画
  - 要清楚动画过程中的几个角色，如下
  ```css
  /* 通过 fade-enter-active 和 fade-leave-active 两个 class，去控制动画全程的过渡属性。设置 opacity 有 0.5 秒的过渡时间，并且在元素进入前和离开后设置 opacity 为 0。 */
  .fade-enter-active,
  .fade-leave-active {
    transition: opacity 0.5s linear;
  }

  .fade-enter-from,
  .fade-leave-to {
    opacity: 0;
  }
  ```


**今日总结**

> 咱们不要因为别人的一些话就受打击了，你有那么脆弱吗？别人说几句话就让你寝食难安？内心足够坚强的人是不会受几句话的影响，因为他清楚的知道自己想要的东西，想要去的地方！

**明日早读**

> 明天周日，睡个懒觉

### 11.7

**今日计划**

- [x] 暂无计划

**学习笔记**

**今日总结**

> 按照月初的计划，上周是对 ts 的进行了总结。下周要重敲 mini-vue 源码，并在掘金上输出文档！加油把！自信是自己给的，从来不是别人施舍！

**明日早读**

- [x] JS 系统脑图
- [x] 第四关脑图

## 第二周

### 11.8

**今日计划**

- [x] 重要任务
  - [x] 玩转 vue3 全家桶
  - [x] 重敲 mini-vue 第一天
    - [x] 输出文档
  - [x] 工作任务
  - [x] 健身计划
- [x] 可选任务
  - [x] 防抖和节流的实现

**学习笔记**

- 玩转 vue3 全家桶
  - 实现 mini-vuex（笔记明天补上）
- 重敲 mini-vue 前置准备（掘金输出）
  - Vue3 新特性
  - TDD 测试驱动开发
- 节流和防抖
  - 节流：频繁的触发一个事件，但是每隔一段时间只触发一次
  - 防抖：频繁的触发一个事件，但是只触发最后一次

**今日总结**

> 有计划，有目标的去实现计划中的事情，这个过程，也是成长。今天看到一句话，说是，每一个成功的都有一段静默的时间。这段静默的时间内，不断的拔高自己，朝着目标前进！目光所至，定能勇往无前！

**明日早读**

- [ ] mini-vue 源码视频

### 11.9

**今日计划**

- [x] 总结 mini-vuex、手写节流和防抖
- [x] 发布 mini-vue<一>
- [x] mini-vue 源码视频
- [x] 工作安排
- [ ] 健身计划

**学习笔记**

节流和防抖

- 节流：根据字面意思，开源节流，请求很多，但是每隔一段时间只触发一次
  - 上拉刷新、高频按钮提交
  - 举个例子：地铁乘车，刷卡过闸机，时间都是固定的
- 防抖：抖动，进进出出，但是只触发最后一次
  - 输入框搜索
  - 举个例子：坐公交车，上车时，每上一个人都会多等几秒（取最后一次）

节流：控制只能一段事件触发一次，有 timer 就退出（地铁闸机）
防抖：控制去最后一次，有 timer 就清空，重新计时（公交上车）

实现

```js
// 节流函数 每段时间触发一次
function throttle(fn,delay){
  var timer = null
  return function(){
    if(timer) return
    timer = setTimeout(()=>{
      // 如果有 this 指向问题
      // 需要使用 fn.apply(this,arguments)
      fn()
      timer = null
    },delay)
  }
}
```
```js
// 防抖函数 每段时间内触发 只取最后一次
function debounce(fn,delay){
  var timer = null
  return function(){
    if(timer){
      clearTimeout(timer)
    }
    timer = setTimeout(()=>{
      fn()
      timer = null
    },delay)
  }
}
```

mini-vuex

```js
import { inject, reactive } from 'vue';

const STORE_KEY = '__store__';

// 还未实现 action 和 getter
class Store {
    constructor(options) {
            this.$options = options;
            // let temp = options.state();
            this._state = reactive({
                data: options.state
            });
            this._mutations = options.mutations;
        }
        // main.js入口处app.use(store)的时候，会执行这个函数
    install(app) {
        app.provide(STORE_KEY, this);
    }
    get state() {
        return this._state.data;
    }
    commit = (type, payload) => {
        const entry = this._mutations[type];
        entry && entry(this.state, payload);
    };
}

export function createStore(options) {
    return new Store(options);
}

export function useStore() {
    return inject(STORE_KEY);
}
```


**今日总结**

> 时刻要记住：路漫漫其修远兮，吾将上下而求索。成功都没有那么容易，一定要将自己压低，沉下来思考问题。

**明日早读**

- [ ] 复习 mini-vuex

### 11.10

**今日计划**

- [x] 闭包的用处、promise 的使用与箭头函数
- [x] 第二篇 mini-vue 文章
  - [x] 需要阅读源码
- [x] 工作计划
  - [ ] v-ben 的项目

**学习笔记**

闭包的用处之一：保护私有变量不会被随意修改

```js
// 闭包的概念：有权访问另一个函数作用域的中的变量
// 产生闭包的原因：1、return 一个函数 2、自执行函数 3、for 循环中有定时器 4、节流和防抖 5、回调函数 6、函数作为参数 7、柯里化
// 巧用闭包
function test() {
    const data = {}
    return {
        set(key, value) {
            data[key] = value
        },
        get(key) {
            return data[key]
        }
    }
}
// 在很多库中，都会使用闭包，保证用户不可以随便的更改全局变量
// 本例中的 data 便只可以通过 set 赋值，get 取值，不会直接修改
const bar = test()
bar.set('name', 'zs')
console.log(bar.get('name'));
```

promise 的使用

```js
// promise 有三种状态 pending(待定的) fulfilled(满足的) rejected(失败的)
const p1 = new Promise((resolved, rejected) => {
    // 执行了 resolved() 状态就变成了 fulfilled
    // resolved()
    // 执行了 rejected() 状态就变成了 rejected 并且会报错
    // rejected()
    // 两个方法都每执行的话，就是等待状态
})
console.log('p1', p1);
const p2 = new Promise(function test(resolve, reject) {
    var timeOut = Math.random() * 2;
    // console.log('set timeout to: ' + timeOut + ' seconds.');
    setTimeout(function() {
        if (timeOut < 1) {
            // console.log('call resolve()...');
            resolve('200 OK');
        } else {
            // console.log('call reject()...');
            reject('500 timeout');
        }
    }, timeOut * 1000);
}).then((res) => {
    console.log('res:', res);
}).catch((err) => {
    console.log('err:', err);
})
```

箭头函数

```js
function foo(num) {
    return (...rest) => {
        // 箭头函数没有 this arguments
        // 所以会去找上层函数的 arguments
        // console.log(arguments[0]);
        //如果一定要传 可以使用 扩展运算符
        console.log(rest);
    }
}
var bar = foo(123)
bar(456)
function bzz(num) {
    return function() {
        console.log(arguments[0]);
    }
}
var baz = bzz()
baz() // 这种情况就是 undefined
baz(123) // 123
```

**今日总结**

> 继续加油噢！要手敲，才能真正的理解原理！

**明日早读**

- [x] 面试题
- [x] JS 系统脑图

### 11.11

**今日计划**

- [x] Map、Set 练习，深入理解
- [x] 玩转 Vue3 全家桶
  - [ ] 手写 mini-vue-router
- [x] 掘金发文-实现收集依赖和触发依赖
  - [x] 周二和周四发文
- [ ] 工作安排
  - [ ] vBen 的学习

**学习笔记**

Vue3 的收集依赖和触发依赖的依据是实现了一个 WeakMap 收集所有的  reactive 对象，并且将其设置为 key，这个 key 又是一个 Map 集合，收集着它所有的属性。然后再实现了一个 Set 收集所有属性的 fn，这个 fn 就是修改属性的函数。

WeakMap 、 Map 和 Set

- WeakMap
  - Weak 是虚弱的意思
  - WeakMap 的 key 一定要是对象，如果是其他的 变量 或者是 Symbol 都会报错
  - WeakMap 的 key 不计入垃圾回收，因为是弱引用，一旦外界的引用消失了，这个 key 就会自动清除，这就是 WeakMap 的意思
  - WeakMap 没有 size，并且不可以遍历，因为它不知道 key 什么时候会清除，它只有 get、set、has 和 delete 方法
- Map
  - Map 的出现是为了加强 Object 在实际应用中的不足，例如 Object 的 key 只能是字符串，而 Map 的 key 可以是 字符串、对象或者 Symbol 等
  - Map 中有 size，并且还有 clear 方法
  - Map 内部部署了 Iterate 是可以遍历的，map.keys()、map.values()、maps.entires()
- Set
  - Set 类似数组，但是它内部的值是唯一的
    - 这点特性可以用于数组的去重 [...new Set(arr)]
  - Set 是使用 add 方法进行添加

mini-vuex 和 mini-vueRouter 内部都是通过 provide 和 inject 来传递数据，并且要使用 install 方法注册到根组件中。这两个的实现，等后面学的更深了，再回过头来自己敲一遍，以便于深入理解。

**今日总结**

> 初级前端步入中高级前端，最好的办法就是务实基础，这样才能触类旁通。以前学 js 基础的时候，对于一些知识的底层原理实现没办法去理解，当然这跟自己的工作阅历也有关系，工作久了，接触的技术面广了，你再回过头去看这些原理知识，这时候你就能知道这样做的好处。再者，当你学完的时候，你再去看进阶的源码，又会有不一样的东西！这就是所谓的成长。 

**明日早读**

- [x] JS 系统脑图
- [ ] 面试题

### 11.12

**今日计划**

- [x] JS 务实基础系列
  - [x] this 与 call、apply 和 bind
- [ ] mini-vue 源码细读
- [x] 工作安排
  - [ ] vben 代码阅读

**学习笔记**

Object 和 Reflect

- Reflect 是 ES6 新增的，它上面的方法实现原型都是 Object
- Reflect 的好处就是将 Object 的操作都变成了函数式
  - 例如
    ```js
    // 获取值
    obj.['xxx']
    obj.xxx
    // reflect
    Reflect.get(target,xxx)
    // 删除值
    delete obj.xxx
    // reflect
    Reflect.deleteProperty(target,xxx)
    // 是否存在
    xxx in obj
    // reflect
    Reflect.has(target,xxx)
    // 等等
    ```

this 的箴言

- this 永远指向调用它的函数
  - this 的值是在运行时获取到的
- 箭头函数没有 this
  - 如果访问 this，则会从外部获取

手写 call、apply 和 bind

```html
<body>
    <h1>call apply bind 都是用来修改 this 指向</h1>
    <ul>
        <li>call 和 apply 的用法原理相似，它们的区别就是 call 是接受一个参数列表 而 apply 是接受一个数组，并且二者都是直接执行函数</li>
        <li>bind 的实现就稍微复杂些，bind 是返回一个函数，柯里化传参，并且还可以使用 new 关键字</li>
    </ul>
    <script>
        // 实现 call
        // 实现步骤
        // 1、首先要检测 context 的值，如果是 不是对象 要先包裹一层对象；如果为 null 或者 undefined 就等于 window
        // 2、为 context 添加函数
        // 3、传入参数并且执行
        // 4、删除 context 上的函数
        // 5、返回结果
        Function.prototype.myCall = function(context) {
            context = context ? Object(context) : window
            context.fn = this
            let arg = [...arguments].slice(1)
            let result = context.fn(...arg)
            delete context.fn
            return result
        }

        // 实现 apply
        // 实现步骤
        // 1、检查 context 的值
        // 2、添加函数
        // 3、arr 是否存在 存在就传参执行，相反就直接执行
        // 4、删除
        // 5、返回结果
        Function.prototype.myApply = function(context, arr) {
            context = context ? Object(context) : window
            context.fn = this
            let result
            if (!arr) {
                result = context.fn()
            } else {
                result = context.fn(...arr)
            }
            delete context.fn
            return result
        }

        // 实现 bind (只实现 柯里化部分)
        // 实现步骤
        // 1、如果 this 不是 function 就直接抛出错误
        // 2、绑定上下文 this
        // 3、返回一个函数 柯里化
        Function.prototype.myBind = function(context) {
            if (typeof this !== 'function') {
                throw new Error('not is Function')
            }
            let self = this
            let args = [...arguments].slice(1)
            return function() {
                let bindArgs = [...arguments]
                return self.apply(context, [args.concat(bindArgs)])
            }
        }
    </script>
</body>
```

**今日总结**

> 之前害怕的一些手写题，经过这一段时间的学习，也解决了。所以说，当你勇敢的直面深渊的凝视，深渊的目光也会躲闪！只有迎难而上之时，便是你即将登顶的时候。山坡上的人很多，都是大家能看到的风景。只有你趴的更高了，才能看到更好的风景。这就是为什么很多人喜欢走那些险境，因为只有这些险境才能看到不一样的风景。今天看到别人的文章，和我一样的等级，内容深浅暂且不说，值得称赞的是他的套路。他在文章的开头，讲了一段故事，是他大学四年做舔狗的故事，每篇说一点，让人不由自主的想看其他的文章。这样阅读量和点赞量就来了！

营销方式

- 讲故事
  - 感觉像在追连续剧
- 奖励机制

**明日早读**

- 暂无计划 

### 11.13~11.14

**今日计划**

- [x] 周复习
- [x] 手写要重点复习
- [ ] mini-vue 源码 reactive 部分

**学习笔记**

> 第五关总结和手写题汇总

**今日总结**

> 不念过往，才是真的对未来负责！咱们不用钻牛角尖，人生都会有遗憾的地方，不可能是一帆风顺的！就像是革命的历程，这不也充满的艰难险阻，几次到达悬崖边上，多亏了正确的决断，才力挽狂澜于不到，扶大厦之将倾！未来已来，向前走！

**明日早读**

- [ ] 6.55 起床
- [ ] 第五关周总结

## 第三周

上周主要是手写了几个面试常考的手写题，也深入理解其原理的实现。本周还要继续的务实基础，阅读源码的同时也要学习 JS 基础。

**本周主题**：务实基础，突破自我

**本周计划**

- js 垃圾回收机制
- 手写深浅拷贝
- 原型和原型链
- Promise 对象

### 11.15

**今日计划**

- [x] 复习上周总结
  - [x] 规划好本周 js 基础任务
- [x] mini-vue 源码任务
  - [x] 还是停留在 reactive 部分 已经有几天了
- [x] 工作安排
- [x] 健身计划

**学习笔记**

JS 的垃圾回收机制：JS 中如果 “可达” 值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。简而言之就是，变量存在引用，包括对象中的键值对的引用，就不会被垃圾回收；

```js
// user 具有对这个对象的引用
let user = {
  name: "John"
};

// 全局变量 "user" 引用了对象 {name："John"}（为简洁起见，我们称它为 John）。John 的 "name" 属性存储一个原始值，所以它被写在对象内部。

// 如果 user 的值被重写了，这个引用就没了：
user = null;
//现在 John 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。
```

- 垃圾回收是自动完成的，我们不能强制执行或是阻止执行。
- 当对象是可达状态时，它一定是存在于内存中的。
- 被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。


> WeakMap 和 WeakSet 弱引用的意思就是，但从根节点开始，如果没有引用这个 key 对象，那么这个 key 就会自动清理。像 Map 中的 key，就不会被垃圾回收。

垃圾回收
	什么是垃圾
		从 global 开始，如果节点的一些值是可以访问到的，这就是可达性。如果访问不到，又存在的值就是垃圾
		不如一桶油漆，从 global 开始流，流到的地方是可达的。流不到的地方则是不可达的。
	垃圾分类
		独立垃圾
			单个对象，没有任何引用指向它
		抱团垃圾
			几个垃圾互相引用彼此，形成了孤岛。global 并没有任何的引用指向它们
	如何找到垃圾
		原则：遍历筛选出可达的值，其它的都是垃圾
		筛选方法
			主流程中会有几个根，如果从根出发，任何被引用的对象以及这个对象的子对象，都会被标记；没被标记的就会被删除
	如何回收垃圾
		分带收集
			对象被分成两组：“新的”和“旧的”
			许多对象出现，完成它们的工作并很快死去，它们可以很快被清理
			那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少
		增量收集
			 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟
			所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理
			这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟
		闲时收集
			垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响

**今日总结**

> 昨晚失眠，导致今天状态不好！主要的原因是自己不能很好的控制入睡，总喜欢翻来覆去。最后不动了，然后心里暗示才睡着！前期是因为环境，后期是因为自己。总之，我务必要好好控制睡眠、饮食，要养成良好的生活习惯！今晚一定能好好睡！相信自己！

**明日早读**

- [ ] 6.55 起床
- [ ] 第五关周总结与面试题